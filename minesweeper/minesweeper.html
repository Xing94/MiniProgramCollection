<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æ‰«é›·</title>
    <style>
        /* styles.css */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
        }

        .container {
            text-align: center;
            max-width: 100%;
            overflow-x: auto;
            /* å…è®¸æ°´å¹³æ»šåŠ¨ */
            background-color: #ffffff;
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 28px;
            margin: 0 0 15px;
            color: #2c3e50;
        }

        .settings {
            margin: 10px 0;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .settings label {
            font-size: 14px;
            color: #555;
        }

        .settings input {
            width: 50px;
            padding: 6px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 5px;
            outline: none;
        }

        .settings input:focus {
            border-color: #2c3e50;
            box-shadow: 0 0 5px rgba(44, 62, 80, 0.3);
        }

        .settings button {
            padding: 6px 12px;
            font-size: 14px;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .controls {
            margin: 15px 0;
        }

        button {
            padding: 8px 16px;
            font-size: 14px;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            opacity: 0.7;
            /* æ˜¾ç¤ºè’™å±‚ */
        }

        .reset-error {
            background-color: #F44336;
        }

        .reset-success {
            background-color: #4CAF50;
        }

        .status {
            font-size: 16px;
            margin-top: 10px;
            color: #555;
        }

        .grid {
            display: grid;
            gap: 4px;
            margin: 15px auto;
            justify-content: flex-start;
            /* æ”¹ä¸ºå·¦å¯¹é½ */
            overflow-x: auto;
            /* å…è®¸æ°´å¹³æ»šåŠ¨ */
            max-width: 100%;
            /* é™åˆ¶æœ€å¤§å®½åº¦ */
            padding: 5px;
            width: max-content;
            /* è®©å®½åº¦æ ¹æ®å†…å®¹è‡ªé€‚åº” */
        }

        .grid div {
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #e0e0e0, #ffffff);
            border: 1px solid #ccc;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .grid div:hover {
            transform: scale(1.05);
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.2);
        }

        .grid div.revealed {
            background: linear-gradient(145deg, #d1d1d1, #e3e3e3);
            border: 1px solid #999;
            box-shadow: none;
            cursor: default;
        }

        .grid div.revealed:hover {
            transform: none;
            box-shadow: none;
        }

        .grid div.mine {
            background-color: #ff4444;
        }

        .grid div.mine::after {
            content: "ğŸ’£";
            font-size: 18px;
        }

        .grid div.flagged {
            background-color: #ffcc00;
        }

        .grid div.flagged::after {
            content: "ğŸš©";
            font-size: 18px;
        }

        .grid div.flagged-wrong {
            background-color: #ff8888;
        }

        .grid div.flagged-wrong::after {
            content: "âœ–";
            font-size: 18px;
            color: #ff0000;
        }

        .toast {
            visibility: hidden;
            /* é»˜è®¤éšè— */
            min-width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 4px;
            padding: 4px 18px;
            margin-bottom: 10px;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(20px);
        }

        .toast.show {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }

        .toast-close {
            background: none;
            border: none;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            margin-left: 20px;
        }

        .toast-success {
            background-color: #4CAF50;
        }

        .toast-error {
            background-color: #F44336;
        }

        .toast-warning {
            background-color: #FF9800;
        }

        /* ç¦æ­¢æ–‡æœ¬é€‰ä¸­ */
        .no-select {
            user-select: none;
            /* ç¦æ­¢æ–‡æœ¬é€‰ä¸­ */
            -webkit-user-select: none;
            /* Safari å’Œ Chrome */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* IE 10+ */
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>æ‰«é›·</h1>

        <!-- Toast å®¹å™¨ -->
        <div id="toastContainer" class="no-select" style="
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          z-index: 1000;
        ">
            <!-- Toast å†…å®¹ä¼šåŠ¨æ€æ’å…¥åˆ°è¿™é‡Œ -->
        </div>

        <div class="settings">
            <label for="rows">Rows:</label>
            <input type="number" id="rows" min="5" max="200" value="10" />
            <label for="cols">Columns:</label>
            <input type="number" id="cols" min="5" max="200" value="30" />
            <label for="mines">Mines:</label>
            <input type="number" id="mines" min="1" max="100" value="50" />
            <button id="apply-settings" class="clickButton">åº”ç”¨è®¾ç½®</button>
        </div>
        <div class="controls">
            <button id="reset" class="clickButton">é‡æ–°å¼€å§‹</button>
            <div class="status">Mines: <span id="mine-count">10</span></div>
        </div>
        <div class="grid no-select"></div>
    </div>
    <script>
        // script.js
        const gridElement = document.querySelector(".grid");
        const mineCountElement = document.getElementById("mine-count");
        const rowsElement = document.getElementById("rows");
        const colsElement = document.getElementById("cols");
        const minesElement = document.getElementById("mines");
        const resetButton = document.getElementById("reset");
        const applySettingsButton = document.getElementById("apply-settings");

        let ROWS = 10;
        let COLS = 30;
        let MINES = 50;

        let board = [];
        let mineLocations = [];
        let revealedCount = 0;
        let gameOver = false;
        let inted = false;

        // Initialize the game
        function init() {
            board = Array.from({
                length: ROWS
            }, () => Array(COLS).fill(0));
            mineLocations = [];
            revealedCount = 0;
            gameOver = false;
            mineCountElement.textContent = MINES;
            rowsElement.value = ROWS;
            colsElement.value = COLS;
            minesElement.value = MINES;

            // Generate mines
            while (mineLocations.length < MINES) {
                const row = Math.floor(Math.random() * ROWS);
                const col = Math.floor(Math.random() * COLS);
                if (!mineLocations.some(([r, c]) => r === row && c === col)) {
                    mineLocations.push([row, col]);
                    board[row][col] = -1; // -1 represents a mine
                }
            }

            // Calculate numbers
            for (let [row, col] of mineLocations) {
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS && board[newRow][newCol] !== -
                            1) {
                            board[newRow][newCol]++;
                        }
                    }
                }
            }

            renderBoard();

            if (inted) {
                showToast("æ¸¸æˆå·²å¼€å§‹ï¼", "success");
            }
            inted = true;
            updateGameState()
        }

        // Render the board
        function renderBoard() {
            gridElement.innerHTML = "";
            gridElement.style.gridTemplateColumns = `repeat(${COLS}, 30px)`;
            gridElement.style.gridTemplateRows = `repeat(${ROWS}, 30px)`;

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement("div");
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener("click", handleCellClick);
                    cell.addEventListener("dblclick", handleCellDoubleClick);
                    cell.addEventListener("contextmenu", handleCellRightClick);
                    gridElement.appendChild(cell);
                }
            }
        }

        // Handle cell click
        function handleCellClick(event) {
            if (gameOver) return;

            const cell = event.target;
            if (cell.classList.contains("flagged")) {
                return; // å¦‚æœæ ¼å­å·²æ ‡è®°ï¼Œåˆ™ä¸å…è®¸ç‚¹å‡»
            }

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (board[row][col] === -1) {
                // Mine clicked
                revealMines();
                gameOver = true;
                updateGameState("error")

            } else {
                revealCell(row, col);
                if (revealedCount === ROWS * COLS - MINES) {
                    gameOver = true;
                    updateGameState("success")
                }
            }
        }

        // Handle cell double-click
        function handleCellDoubleClick(event) {
            if (gameOver) return;

            const cell = event.target;
            if (cell.classList.contains("flagged")) {
                return; // å¦‚æœæ ¼å­å·²æ ‡è®°ï¼Œåˆ™ä¸å…è®¸åŒå‡»
            }

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);

            if (board[row][col] > 0) {
                const flaggedCount = countFlaggedNeighbors(row, col);
                if (flaggedCount === board[row][col]) {
                    revealNeighbors(row, col);
                } else {
                    showToast("æ ‡è®°çš„åœ°é›·æ•°é‡ä¸æ•°å­—ä¸åŒ¹é…ï¼", "error");
                }
            }
        }

        // Count flagged neighbors
        function countFlaggedNeighbors(row, col) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newRow = row + i;
                    const newCol = col + j;
                    if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                        const cell = document.querySelector(`.grid div[data-row="${newRow}"][data-col="${newCol}"]`);
                        if (cell.classList.contains("flagged")) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        // Reveal neighbors
        function revealNeighbors(row, col) {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newRow = row + i;
                    const newCol = col + j;
                    if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                        const cell = document.querySelector(`.grid div[data-row="${newRow}"][data-col="${newCol}"]`);
                        if (!cell.classList.contains("revealed") && !cell.classList.contains("flagged")) {
                            if (board[newRow][newCol] === -1) {
                                // Mine revealed
                                revealMines();
                                gameOver = true;
                                gameOverElement.style.display = "block";
                                return;
                            } else {
                                revealCell(newRow, newCol);
                            }
                        }
                    }
                }
            }
            if (revealedCount === ROWS * COLS - MINES) {
                gameOver = true;
                updateGameState("success")
            }
        }

        // Handle cell right-click (flag)
        function handleCellRightClick(event) {
            event.preventDefault();
            if (gameOver) return;

            const cell = event.target;
            if (!cell.classList.contains("revealed")) {
                cell.classList.toggle("flagged");
                updateMineCount();
            }
        }

        // Reveal a cell
        function revealCell(row, col) {
            const cell = document.querySelector(`.grid div[data-row="${row}"][data-col="${col}"]`);
            if (cell.classList.contains("revealed") || cell.classList.contains("flagged")) return;

            cell.classList.add("revealed");
            revealedCount++;

            if (board[row][col] > 0) {
                cell.textContent = board[row][col];
            } else if (board[row][col] === 0) {
                // Reveal adjacent cells
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS) {
                            revealCell(newRow, newCol);
                        }
                    }
                }
            }
        }

        // Reveal all mines and check for wrong flags
        function revealMines() {
            for (let [row, col] of mineLocations) {
                const cell = document.querySelector(`.grid div[data-row="${row}"][data-col="${col}"]`);
                if (!cell.classList.contains("flagged")) {
                    cell.classList.add("mine");
                }
            }

            // Check for wrong flags
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.querySelector(`.grid div[data-row="${row}"][data-col="${col}"]`);
                    if (cell.classList.contains("flagged") && board[row][col] !== -1) {
                        cell.classList.add("flagged-wrong");
                    }
                }
            }
        }

        // Update mine count
        function updateMineCount() {
            const flaggedCount = document.querySelectorAll(".flagged").length;
            mineCountElement.textContent = MINES - flaggedCount;
        }

        // Apply settings
        applySettingsButton.addEventListener("click", () => {
            const newRows = parseInt(document.getElementById("rows").value);
            const newCols = parseInt(document.getElementById("cols").value);
            const newMines = parseInt(document.getElementById("mines").value);

            if (newRows * newCols <= newMines) {
                showToast("åœ°é›·æ•°é‡ä¸èƒ½è¶…è¿‡æ ¼å­æ€»æ•°ï¼", "error");
                return;
            }

            ROWS = newRows;
            COLS = newCols;
            MINES = newMines;
            init();
        });

        function showToast(message, type = 'default', duration = 1500) {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
        ${message}
        <button class="toast-close" onclick="this.parentElement.remove()">Ã—</button>
    `;

            const toastContainer = document.getElementById('toastContainer');
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            if (duration > 0) {
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }, duration);
            }
        }

        function updateGameState(gameState = "default") {
            if (gameState === 'error') {
                resetButton.className = 'reset-error';
                resetButton.textContent = 'æ¸¸æˆå¤±è´¥';
                showToast("æ¸¸æˆç»“æŸï¼", "error");
            } else if (gameState === 'success') {
                resetButton.className = 'reset-success';
                resetButton.textContent = 'æ¸¸æˆæˆåŠŸ';
                showToast("æ¸¸æˆæˆåŠŸ", "success");
            } else {
                resetButton.className = '';
                resetButton.textContent = 'é‡æ–°å¼€å§‹';
            }
        }

        // Reset the game
        resetButton.addEventListener("click", init);

        // Start the game
        init();
    </script>
</body>

</html>